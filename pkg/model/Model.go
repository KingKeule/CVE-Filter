package model

import (
	"fmt"
	"log"
	"reflect"
	"sort"
)

var ListOfCVEStrs []string
var ListOfCVEs []CVE
var ListOfFilteredCVEs []CVE

// Sort a list of CVEs by CVSS version
func SortCVSSVersionScore(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest CVSS version is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].CVSSversion > listOfCVEs[j].CVSSversion
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest CVSS version is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].CVSSversion < listOfCVEs[j].CVSSversion
		})
	}

	return listOfCVEs
}

// Sort a list of CVEs by base score
func SortBaseScore(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore > listOfCVEs[j].BaseScore
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore < listOfCVEs[j].BaseScore
		})
	}

	return listOfCVEs
}

// Sort a list of CVEs by CVE ID number
func SortYear(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID > listOfCVEs[j].ID
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID < listOfCVEs[j].ID
		})
	}

	return listOfCVEs
}

// Convert a struct into a string array and takes only the specified number of fields
func ConvCVEStruct(data interface{}, numOfFields int, forExport bool) []string {
	v := reflect.ValueOf(data)
	n := numOfFields
	rowContents := make([]string, n)
	for i := 0; i < n; i++ {
		x := v.Field(i)
		//	Add an invisible "no break space" character after the origin data (CVSS version, CVSS base score)
		// so that the value in the export is not interpreted as a date by Excel.
		if forExport && (i == 1 || i == 2) {
			rowContents[i] = fmt.Sprintf("%v%s", x.Interface(), []byte{160})
		} else {
			rowContents[i] = fmt.Sprintf("%v", x.Interface())
		}
	}
	return rowContents
}

// Count all CVEs with CVSS version 2.0 in the unfiltered CVE list
func CountCVSSv2() int {
	cnt := 0
	for _, cve := range ListOfCVEs {
		if cve.CVSSversion == "2.0" {
			cnt += 1
		}
	}
	return cnt
}

// Count all CVEs with CVSS version 2.0 in the filtered CVE list
func CountFiltCVSSv2() int {
	cnt := 0
	for _, cve := range ListOfFilteredCVEs {
		if cve.CVSSversion == "2.0" {
			cnt += 1
		}
	}
	return cnt
}
