package model

import (
	"fmt"
	"log"
	"reflect"
	"sort"
)

var ListOfCVEStrs []string
var ListOfCVEs []CVE
var ListOfFilteredCVEs []CVE

// Sort a list of CVEs by base score
func SortBaseScore(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore > listOfCVEs[j].BaseScore
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore < listOfCVEs[j].BaseScore
		})
	}

	return listOfCVEs
}

// Sort a list of CVEs by CVE ID number
func SortYear(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID > listOfCVEs[j].ID
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID < listOfCVEs[j].ID
		})
	}

	return listOfCVEs
}

// Convert a struct into a string array and takes only the specified number of fields
func ConvCVEStruct(data interface{}, numOfFields int) []string {
	v := reflect.ValueOf(data)
	n := numOfFields
	rowContents := make([]string, n)
	for i := 0; i < n; i++ {
		x := v.Field(i)
		s := fmt.Sprintf("%v", x.Interface())
		rowContents[i] = s
	}
	return rowContents
}
