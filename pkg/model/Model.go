package model

import (
	"fmt"
	"log"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

var ListOfCVEStrs []string
var ListOfCVEs []CVE
var ListOfFilteredCVEs []CVE

// Sort a list of CVEs by CVSS version
func SortCVSSVersionScore(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest CVSS version is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].CVSSversion > listOfCVEs[j].CVSSversion
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest CVSS version is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].CVSSversion < listOfCVEs[j].CVSSversion
		})
	}

	return listOfCVEs
}

// Sort a list of CVEs by base score
func SortBaseScore(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore > listOfCVEs[j].BaseScore
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest base score is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].BaseScore < listOfCVEs[j].BaseScore
		})
	}

	return listOfCVEs
}

// Sort a list of CVEs by CVE ID number
func SortYear(listOfCVEs []CVE, scoreSortHightoDown bool) []CVE {
	if scoreSortHightoDown {
		log.Println("Sort the CVEs so that the one with the highest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID > listOfCVEs[j].ID
		})
	} else {
		log.Println("Sort the CVEs so that the one with the lowest ID number is at the top.")
		sort.SliceStable(listOfCVEs, func(i, j int) bool {
			return listOfCVEs[i].ID < listOfCVEs[j].ID
		})
	}

	return listOfCVEs
}

// Convert a struct into a string array and takes only the specified number of fields
func ConvCVEStruct(data interface{}, numOfFields int, forExport bool) []string {
	v := reflect.ValueOf(data)
	n := numOfFields
	rowContents := make([]string, n)
	for i := 0; i < n; i++ {
		x := v.Field(i)

		// data adaptations for CSV export
		if forExport && (i == 1 || i == 2) {
			//	Add an invisible "no break space" character after the origin data (CVSS version, CVSS base score)
			// so that the value in the export is not interpreted as a date by Excel.
			rowContents[i] = fmt.Sprintf("%v%s", x.Interface(), []byte{160})
		} else {
			rowContents[i] = fmt.Sprintf("%v", x.Interface())
		}

		// data adaptations for for internal display
		// skip the base severity column
		if !forExport && i > 3 {
			rowContents[i-1] = fmt.Sprintf("%v", x.Interface())
		}
	}
	return rowContents
}

// Count all CVEs with CVSS version 2.0 in the unfiltered CVE list
func CountCVSSv2() int {
	cnt := 0
	for _, cve := range ListOfCVEs {
		if cve.CVSSversion == "2.0" {
			cnt += 1
		}
	}
	return cnt
}

// Count all CVEs with CVSS version 2.0 in the filtered CVE list
func CountFiltCVSSv2() int {
	cnt := 0
	for _, cve := range ListOfFilteredCVEs {
		if cve.CVSSversion == "2.0" {
			cnt += 1
		}
	}
	return cnt
}

// Takes a CSV string array and builds it to a list of cve structs.
// The correct order of the CSV string values is not checked but expected.
func ConvertCSVStringsToCVEs(importedCSVStrings [][]string) ([]CVE, error) {
	var listOfCVETmp []CVE

	for i, csvString := range importedCSVStrings {
		var cve CVE
		if i != 0 { // Always ignore head line
			cve.ID = csvString[0]

			// Check data from "CVSS version" and "base scor"e for the Unicode replacement character (0xFFFD, 65533).
			// This is set at CSV import , if e.g. the hidden symbol "A0" https://en.wikipedia.org/wiki/Latin-1_Supplement is given.
			// fmt.Printf("CSV string: %s (Unicode: %x) \n", csvString[2], []byte(csvString[i]))
			// data := []rune(csvString[2])
			// for j := 0; j < len(data); j++ {
			// 	fmt.Printf("Rune pos %d:  Char %c (Unicode: %U) \n", j, data[j], data[j])
			// }
			// fmt.Println()

			if strings.ContainsRune(csvString[1], 0xFFFD) {
				log.Printf("The CSV string \"%s\" for the CVSS version contains a special rune. This rune will be removed.", csvString[1])
				cve.CVSSversion = csvString[1][0 : len(csvString[1])-1]
			} else {
				cve.CVSSversion = csvString[1]
			}

			if strings.ContainsRune(csvString[2], 0xFFFD) {
				log.Printf("The CSV string \"%s\" for the CVSS base score contains a special rune. This rune will be removed.", csvString[2])
				if s, err := strconv.ParseFloat(csvString[2][0:len(csvString[2])-1], 64); err == nil {
					cve.BaseScore = s
				} else {
					log.Printf("An error occurred while parsing the CSV string for the base score: %s", err)
					return listOfCVETmp, err
				}
			} else {
				if s, err := strconv.ParseFloat(csvString[2], 64); err == nil {
					cve.BaseScore = s
				} else {
					log.Println(err)
					return listOfCVETmp, err
				}
			}

			cve.BaseSeverity = csvString[3]
			cve.AttackVector = csvString[4]
			cve.AttackComplexity = csvString[5]
			cve.PrivilegesRequired = csvString[6]
			cve.UserInteraction = csvString[7]
			cve.Scope = csvString[8]
			cve.Authentication = csvString[9]
			cve.Confidentiality = csvString[10]
			cve.Integrity = csvString[11]
			cve.Availability = csvString[12]
			cve.Description = csvString[13]
			listOfCVETmp = append(listOfCVETmp, cve)
		}
	}
	return listOfCVETmp, nil
}
