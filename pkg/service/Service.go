package service

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"

	"fyne.io/fyne/v2/widget"
	"github.com/KingKeule/CVE-Filter/pkg/config"
	"github.com/KingKeule/CVE-Filter/pkg/model"
)

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^CVE-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(listOfCVEStr []string, progressInfo *widget.ProgressBar, stopDownload chan bool) (error, []model.CVE, []string) {

	var listOfCVEs []model.CVE
	var notFoundOnNVD []string
	var errGlobal error

	for i, cveIDStr := range listOfCVEStr {
		select {
		case <-stopDownload:
			log.Println("The user aborted the download process.")
			return errGlobal, listOfCVEs, notFoundOnNVD
		default:
			log.Printf("%s: Try to download the information from NVD", cveIDStr)

			// API info: https://nvd.nist.gov/developers/vulnerabilities
			response, err := http.Get("https://services.nvd.nist.gov/rest/json/cve/1.0/" + cveIDStr)
			if err != nil {
				errGlobal = err
				break
			}

			responseData, err := ioutil.ReadAll(response.Body)
			if err != nil {
				errGlobal = err
				break
			}

			lenResp := len(responseData)
			log.Printf("%s: Recieved %d bytes from NVD.\n", cveIDStr, lenResp)
			if lenResp < 100 {
				nvdResp := string(responseData)
				if strings.Contains(nvdResp, "Unable to find vuln") {
					notFoundOnNVD = append(notFoundOnNVD, cveIDStr)
					log.Printf("%s: The CVE could not be found at NVD.", cveIDStr)
					progressInfo.SetValue(float64(i+1) / float64(len(listOfCVEStr)))
				} else {
					errGlobal = errors.New(nvdResp)
				}
			} else {
				var resp NVDResponse
				log.Printf("%s: The CVE was found at NVD and the JSON response is now trying to marshall.", cveIDStr)
				err := json.Unmarshal(responseData, &resp)
				if err != nil {
					errGlobal = err
					break
				}

				var cve model.CVE
				cve.ID = cveIDStr
				cve.BaseScore = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.BaseScore
				cve.BaseSeverity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.BaseSeverity
				cve.AttackVector = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AttackVector
				cve.AttackComplexity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AttackComplexity
				cve.PrivilegesRequired = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.PrivilegesRequired
				cve.UserInteraction = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.UserInteraction
				cve.Scope = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.Scope
				cve.Confidentiality = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.ConfidentialityImpact
				cve.Integrity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.IntegrityImpact
				cve.Availability = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AvailabilityImpact
				cve.Description = resp.Result.CVEItems[0].Cve.Description.DescriptionData[0].Value

				listOfCVEs = append(listOfCVEs, cve)
				log.Printf("%s: The CVE was successfully added to the downloaded list.", cveIDStr)
				progressInfo.SetValue(float64(i+1) / float64(len(listOfCVEStr)))
			}
		}
	}
	return errGlobal, listOfCVEs, notFoundOnNVD
}

// Check if the CVE matches the different filter criteria
func FilterCVE(listOfCVE []model.CVE, cveFilter config.CVEFilter) []model.CVE {
	log.Println("Check if the CVE matches the different filter criteria.")
	logMsgFilterOut := "but the corresponding filter is not activated. CVE is filtered out."

	var listOfFilteredCVEs []model.CVE

	for _, cve := range listOfCVE {

		//Filter only by CVSS base score range when no base severity category is checked otherwise filter by base severity category
		filterValueSevLow, _ := cveFilter.BindingData.FilterBaseSeverityLow.Get()
		filterValueSevMed, _ := cveFilter.BindingData.FilterBaseSeverityMed.Get()
		filterValueSevHigh, _ := cveFilter.BindingData.FilterBaseSeverityHigh.Get()
		filterValueSevCrit, _ := cveFilter.BindingData.FilterBaseSeverityCrit.Get()

		if !filterValueSevLow && !filterValueSevMed && !filterValueSevHigh && !filterValueSevCrit {
			valueBaseScoreMin, _ := cveFilter.BindingData.FilterBaseScoreMin.Get()
			valueBaseScoreMax, _ := cveFilter.BindingData.FilterBaseScoreMax.Get()
			if (cve.BaseScore < valueBaseScoreMin) || (cve.BaseScore > valueBaseScoreMax) {
				log.Printf("%s: Base Score (%0.1f) is not in the filter range (%0.1f - %0.1f). CVE is filtered out.", cve.ID, cve.BaseScore, valueBaseScoreMin, valueBaseScoreMax)
				goto LOOPEND
			}
		} else {
			if cve.BaseSeverity == "LOW" && !filterValueSevLow {
				log.Printf("%s: Base Severity is \"LOW\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "MEDIUM" && !filterValueSevMed {
				log.Printf("%s: Base Severity is \"MEDIUM\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "HIGH" && !filterValueSevHigh {
				log.Printf("%s: Base Severity is \"HIGH\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "CRITICAL" && !filterValueSevCrit {
				log.Printf("%s: Base Severity is \"CRITICAL\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
		}

		//Filter by CVSS metrics
		switch cve.AttackVector {
		case "NETWORK":
			if value, _ := cveFilter.BindingData.FilterAVN.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "ADJACENT":
			if value, _ := cveFilter.BindingData.FilterAVA.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOCAL":
			if value, _ := cveFilter.BindingData.FilterAVL.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "PHYSICAL":
			if value, _ := cveFilter.BindingData.FilterAVP.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.AttackComplexity {
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterACL.Get(); !value {
				log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterACH.Get(); !value {
				log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.PrivilegesRequired {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterPRN.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterPRL.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterPRH.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.UserInteraction {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterUIN.Get(); !value {
				log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
				goto LOOPEND
			}
		case "REQUIRED":
			if value, _ := cveFilter.BindingData.FilterUIR.Get(); !value {
				log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Scope {
		case "UNCHANGED":
			if value, _ := cveFilter.BindingData.FilterSU.Get(); !value {
				log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
				goto LOOPEND
			}
		case "CHANGED":
			if value, _ := cveFilter.BindingData.FilterSC.Get(); !value {
				log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Confidentiality {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterCN.Get(); !value {
				log.Printf("%s: Confidentiality is \"%s\" %s", cve.ID, cve.Confidentiality, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterCL.Get(); !value {
				log.Printf("%s: Confidentiality is \"%s\" %s", cve.ID, cve.Confidentiality, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterCH.Get(); !value {
				log.Printf("%s: Confidentiality is \"%s\" %s", cve.ID, cve.Confidentiality, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Integrity {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterIN.Get(); !value {
				log.Printf("%s: Integrity is \"%s\" %s", cve.ID, cve.Integrity, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterIL.Get(); !value {
				log.Printf("%s: Integrity is \"%s\" %s", cve.ID, cve.Integrity, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterIH.Get(); !value {
				log.Printf("%s: Integrity is \"%s\" %s", cve.ID, cve.Integrity, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Availability {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterAN.Get(); !value {
				log.Printf("%s: Availability is \"%s\" %s", cve.ID, cve.Availability, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterAL.Get(); !value {
				log.Printf("%s: Availability is \"%s\" %s", cve.ID, cve.Availability, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterAH.Get(); !value {
				log.Printf("%s: Availability is \"%s\" %s", cve.ID, cve.Availability, logMsgFilterOut)
				goto LOOPEND
			}
		}

		// 	Finally, add the CVE to the list as all filter criteria match
		listOfFilteredCVEs = append(listOfFilteredCVEs, cve)

	LOOPEND:
	}

	log.Println("The CVE filter process is finished.")
	return listOfFilteredCVEs
}

// Export as a csv file with semicolon as seperator
func ExportCVEListasCSV(fileURI string, tableHeadline []string, listOfCVE []model.CVE) error {
	var exportData = [][]string{tableHeadline}
	for _, cve := range listOfCVE {
		tmpArray := model.ConvCVEStruct(cve, len(tableHeadline))
		exportData = append(exportData, tmpArray)
	}

	if fileURI == "" {
		log.Println("File name for export is missing.")
		return nil
	}

	file, err := os.Create(fileURI)
	defer file.Close()
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err
	}

	csvwriter := csv.NewWriter(file)
	csvwriter.Comma = ';'
	defer csvwriter.Flush()

	err = csvwriter.WriteAll(exportData)
	if err != nil {
		log.Println(err)
		return err
	}

	log.Printf("Export saved to \"%s\"", file.Name())

	return nil
}
