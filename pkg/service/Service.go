package service

import (
	"encoding/csv"
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/KingKeule/CVE-Filter/pkg/config"
	"github.com/KingKeule/CVE-Filter/pkg/model"
)

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^CVE-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(listOfCVEStr []string) (bool, []model.CVE) {

	var listOfCVEs []model.CVE
	result := true
	searchStrVector1 := `attackVector`
	searchStrVector2 := `,"baseScore`
	searchStrScore1 := `baseScore":`
	searchStrScore2 := `,"baseSeverity`
	searchStrScore3 := `"},"exploitabilityScore`

	for _, cveIDStr := range listOfCVEStr {
		log.Printf("Try to download the information for \"%s\" from NVD", cveIDStr)

		// API info: https://nvd.nist.gov/developers/vulnerabilities
		response, err := http.Get("https://services.nvd.nist.gov/rest/json/cve/1.0/" + cveIDStr)
		if err != nil {
			log.Println(err.Error())
			result = false
			break
		}

		responseData, err := ioutil.ReadAll(response.Body)
		if err != nil {
			log.Println(err.Error())
			result = false
			break
		}

		lenResp := len(responseData)
		log.Printf("Recieved %d bytes from NVD.\n", lenResp)
		nvdResp := string(responseData)
		//log.Println(nvdResp)

		if lenResp < 100 { // check for bad response: {"message":"Unable to find vuln CVE-XXXX-XXXXX"}
			log.Printf("Problem: %s", nvdResp)
			result = false
			break
		} else {
			// Extract the substring with the CVSS vector information
			posFirst := strings.Index(nvdResp, searchStrVector1)
			posLast := strings.Index(nvdResp, searchStrVector2)
			cvss31MetricSlice := nvdResp[posFirst:posLast]
			cvss31Metrics := strings.Split(cvss31MetricSlice, ",")

			// Extract the substring with the CVSS score information
			scorePosFirst := strings.Index(nvdResp, searchStrScore1)
			scorePosLast := strings.Index(nvdResp, searchStrScore2)
			cvss31BaseScore := nvdResp[(scorePosFirst + len(searchStrScore1)):scorePosLast]

			// Extract the substring with the CVSS score information
			severityPosFirst := strings.Index(nvdResp, searchStrScore2)
			severityPosLast := strings.Index(nvdResp, searchStrScore3)
			cvss31BaseSeverity := nvdResp[(severityPosFirst + len(searchStrScore2) + 3):severityPosLast]

			var cve model.CVE
			cve.ID = cveIDStr
			cve.Score, _ = strconv.ParseFloat(cvss31BaseScore, 64)
			cve.AttackVector = cvss31Metrics[0][15 : len(cvss31Metrics[0])-1]
			cve.AttackComplexity = cvss31Metrics[1][20 : len(cvss31Metrics[1])-1]
			cve.PrivilegesRequired = cvss31Metrics[2][22 : len(cvss31Metrics[2])-1]
			cve.UserInteraction = cvss31Metrics[3][19 : len(cvss31Metrics[3])-1]
			cve.Scope = cvss31Metrics[4][9 : len(cvss31Metrics[4])-1]
			cve.Confidentiality = cvss31Metrics[5][25 : len(cvss31Metrics[5])-1]
			cve.Integrity = cvss31Metrics[6][19 : len(cvss31Metrics[6])-1]
			cve.Availability = cvss31Metrics[7][22 : len(cvss31Metrics[7])-1]
			if cvss31BaseSeverity == "LOW" {
				cve.BaseSeverityLow = true
			}
			if cvss31BaseSeverity == "MEDIUM" {
				cve.BaseSeverityMed = true
			}
			if cvss31BaseSeverity == "HIGH" {
				cve.BaseSeverityHigh = true
			}
			if cvss31BaseSeverity == "CRITICAL" {
				cve.BaseSeverityCrit = true
			}

			listOfCVEs = append(listOfCVEs, cve)
		}
	}
	return result, listOfCVEs
}

// Check if the CVE matches the different filter criteria
func FilterCVE(listOfCVE []model.CVE, cveFilter config.CVEFilter) []model.CVE {
	log.Println("Check if the CVE matches the different filter criteria.")

	var listOfFilteredCVEs []model.CVE

	for _, cve := range listOfCVE {

		//Filter only by CVSS base score range when no base severity category is checked otherwise filter by base severity category
		filterValueSevLow, _ := cveFilter.BindingData.FilterBaseSeverityLow.Get()
		filterValueSevMed, _ := cveFilter.BindingData.FilterBaseSeverityMed.Get()
		filterValueSevHigh, _ := cveFilter.BindingData.FilterBaseSeverityHigh.Get()
		filterValueSevCrit, _ := cveFilter.BindingData.FilterBaseSeverityCrit.Get()

		if !filterValueSevLow && !filterValueSevMed && !filterValueSevHigh && !filterValueSevCrit {
			valueScoreMin, _ := cveFilter.BindingData.FilterBaseScoreMin.Get()
			valueScoreMax, _ := cveFilter.BindingData.FilterBaseScoreMax.Get()
			if (cve.Score < valueScoreMin) || (cve.Score > valueScoreMax) {
				log.Printf("%s: Base Score (%0.1f) is not in the filter range (%0.1f - %0.1f). CVE is filtered out.", cve.ID, cve.Score, valueScoreMin, valueScoreMax)
				goto LOOPEND
			}
		} else {
			if cve.BaseSeverityLow && !filterValueSevLow {
				log.Printf("%s: Base Severity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverityMed && !filterValueSevMed {
				log.Printf("%s: Base Severity is not \"MEDIUM\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverityHigh && !filterValueSevHigh {
				log.Printf("%s: Base Severity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverityCrit && !filterValueSevCrit {
				log.Printf("%s: Base Severity is not \"CRITICAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		//Filter by CVSS metrics
		switch cve.AttackVector {
		case "NETWORK":
			if value, _ := cveFilter.BindingData.FilterAVN.Get(); !value {
				log.Printf("%s: Attack vector is not \"NETWORK\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "ADJACENT":
			if value, _ := cveFilter.BindingData.FilterAVA.Get(); !value {
				log.Printf("%s: Attack vector is not \"ADJACENT\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOCAL":
			if value, _ := cveFilter.BindingData.FilterAVL.Get(); !value {
				log.Printf("%s: Attack vector is not \"LOCAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "PHYSICAL":
			if value, _ := cveFilter.BindingData.FilterAVP.Get(); !value {
				log.Printf("%s: Attack vector is not \"PHYSICAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.AttackComplexity {
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterACL.Get(); !value {
				log.Printf("%s: Attack complexity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterACH.Get(); !value {
				log.Printf("%s: Attack complexity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.PrivilegesRequired {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterPRN.Get(); !value {
				log.Printf("%s: Privileges required is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterPRL.Get(); !value {
				log.Printf("%s: Privileges required is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterPRH.Get(); !value {
				log.Printf("%s: Privileges required is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.UserInteraction {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterUIN.Get(); !value {
				log.Printf("%s: User interaction is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "REQUIRED":
			if value, _ := cveFilter.BindingData.FilterUIR.Get(); !value {
				log.Printf("%s: User interaction is not \"REQUIRED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Scope {
		case "UNCHANGED":
			if value, _ := cveFilter.BindingData.FilterSU.Get(); !value {
				log.Printf("%s: Scope is not \"UNCHANGED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "CHANGED":
			if value, _ := cveFilter.BindingData.FilterSC.Get(); !value {
				log.Printf("%s: Scope is not \"CHANGED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Confidentiality {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterCN.Get(); !value {
				log.Printf("%s: Confidentiality is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterCL.Get(); !value {
				log.Printf("%s: Confidentiality is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterCH.Get(); !value {
				log.Printf("%s: Confidentiality is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Integrity {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterIN.Get(); !value {
				log.Printf("%s: Integrity is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterIL.Get(); !value {
				log.Printf("%s: Integrity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterIH.Get(); !value {
				log.Printf("%s: Integrity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Availability {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterAN.Get(); !value {
				log.Printf("%s: Availability is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterAL.Get(); !value {
				log.Printf("%s: Availability is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterAH.Get(); !value {
				log.Printf("%s: Availability required is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		// 	Finally, add the CVE to the list as all filter criteria match
		listOfFilteredCVEs = append(listOfFilteredCVEs, cve)

	LOOPEND:
	}

	return listOfFilteredCVEs
}

// Export as a csv file with semicolon as seperator
func ExportCVEListasCSV(fileURI string, tableHeadline []string, listOfCVE []model.CVE) error {
	var exportData = [][]string{tableHeadline}
	for _, cve := range listOfCVE {
		tmpArray := model.ConvCVEStruct(cve, len(tableHeadline))
		exportData = append(exportData, tmpArray)
	}

	if fileURI == "" {
		log.Println("File name for export is missing.")
		return errors.New("")
	}

	file, err := os.Create(fileURI)
	defer file.Close()
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err
	}

	csvwriter := csv.NewWriter(file)
	csvwriter.Comma = ';'
	defer csvwriter.Flush()

	err = csvwriter.WriteAll(exportData)
	if err != nil {
		log.Println(err)
		return err
	}

	log.Printf("Export saved to \"%s\"", file.Name())

	return nil
}
