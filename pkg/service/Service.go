package service

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"fyne.io/fyne/v2/widget"
	"github.com/KingKeule/CVE-Filter/pkg/config"
	"github.com/KingKeule/CVE-Filter/pkg/model"
)

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^(cve|CVE)-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// This function checks if the user input (string) contains only numbers.
func CheckUserDelayNum(delayString string) bool {
	s := strings.TrimSpace(delayString)
	r := regexp.MustCompile(`^\d+$`)
	return r.Match([]byte(s))
}

func finallyLoopIter(i int, progressInfo *widget.ProgressBar) int {
	i++
	progressInfo.SetValue(float64(i))
	return i
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(bindingDataPoolGui model.BindingDataGui, FastDL bool, progressInfo *widget.ProgressBar, stopDownload chan bool) (error, []model.CVE, []string) {

	var listOfCVEs []model.CVE
	var notFoundOnNVD []string
	var errGlobal error

	// Set a custom mininum and maximum for the download progress bar
	progressInfo.Min = float64(0)
	progressInfo.Max = float64(len(model.ListOfCVEStrs))

	// Use a custom function as a post statement of the for-loop, for better handling of loop breaks.
	// for i, cveIDStr := range model.ListOfCVEStrs {
	for i := 0; i < len(model.ListOfCVEStrs); i = finallyLoopIter(i, progressInfo) {
		select {
		case <-stopDownload:
			log.Println("The user aborted the download process.")
			return errGlobal, listOfCVEs, notFoundOnNVD
		default:
			// Add the delay at download mode "slow" to prevent blocking from server
			if i != 0 && (!FastDL) {
				downloadDelay, err := bindingDataPoolGui.DownloadDelaySecData.Get()
				if err != nil {
					return err, listOfCVEs, notFoundOnNVD
				}
				delayValue, _ := strconv.Atoi(downloadDelay)
				log.Printf("Download mode: \"slow\". The next download will start in \"%d\" seconds.", delayValue)

				select {
				case <-stopDownload:
					break
				case <-time.After(time.Duration(delayValue) * time.Second):
					break
				}
			}

			cveIDStr := model.ListOfCVEStrs[i]
			log.Printf("%s: Try to download the information from NVD", cveIDStr)

			// setup the network timeout
			DownloadTimeoutSecStr, err := bindingDataPoolGui.NetworkTimeoutSecData.Get()
			if err != nil {
				log.Printf("Error by setting the network timeout. Error: %s", err)
				return err, listOfCVEs, notFoundOnNVD
			}
			networkTimeoutSec, err := strconv.Atoi(DownloadTimeoutSecStr)
			if err != nil {
				log.Printf("Error by setting the network timeout. Error: %s", err)
				return err, listOfCVEs, notFoundOnNVD
			}

			// setup the right HTTP configuration
			httpClient := &http.Client{Timeout: time.Duration(networkTimeoutSec) * time.Second}

			proxyStr, err := bindingDataPoolGui.ProxyData.Get()
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}
			if proxyStr != "" {
				proxy, err := url.Parse(proxyStr)
				if err != nil {
					return err, listOfCVEs, notFoundOnNVD
				}

				transConf := &http.Transport{
					// TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // only for debugging
					Proxy: http.ProxyURL(proxy),
				}
				httpClient = &http.Client{Timeout: time.Duration(networkTimeoutSec) * time.Second, Transport: transConf}
				log.Printf("Proxy is enabled for download: %s", proxy)
			}

			NVDApiURL, err := bindingDataPoolGui.NVDApiURLData.Get()
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}
			req, err := http.NewRequest("GET", NVDApiURL+cveIDStr, nil)
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}

			// Set the user API key at fast download
			if (FastDL) && (len(model.ListOfCVEStrs) > 1) {
				apiKey, _ := bindingDataPoolGui.ApiKey.Get()
				req.Header.Set("apiKey", apiKey)
			}

			// Send the request
			response, err := httpClient.Do(req)
			if err != nil {
				if os.IsTimeout(err) {
					log.Printf("Timeout error: %v\n", err)
				}
				return err, listOfCVEs, notFoundOnNVD
			}

			// Check for server message in the response header.
			// If a wrong API key is used, cancel the download.
			if FastDL {
				if response.Header.Get("message") == "Invalid apiKey." {
					log.Printf("The given API key is not valid. Please enter a valid API key.")
					return errors.New("Invalid API Key. Please enter a valid API key."), listOfCVEs, notFoundOnNVD
				} else {
					log.Printf("The given API key is valid and used.")
				}
			}

			responseData, err := io.ReadAll(response.Body)
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}

			// Log of raw network responses for debugging
			logNetRaw, err := bindingDataPoolGui.LogNetworkRaw.Get()
			if logNetRaw && err == nil {
				log.Println("Response payload data:")
				log.Println(string(responseData))
			} else {
				log.Println("Logging of raw network responses deactivated or config value error.")
			}

			lenResp := len(responseData)
			log.Printf("%s: Recieved %d bytes from NVD.\n", cveIDStr, lenResp)
			if lenResp < 100 {
				// Check if the server is blocking the download in case of too many requests without key.
				// If so, cancel the download.
				nvdResp := string(responseData)
				if strings.Contains(nvdResp, "<html><body><h1>403 Forbidden</h1>") {
					log.Printf("%s: The request is blocked by the server.", cveIDStr)
					return errors.New(nvdResp), listOfCVEs, notFoundOnNVD
				}
			} else {
				var resp NVDResponse
				log.Printf("%s: The CVE was found at NVD and the JSON response is now trying to marshall.", cveIDStr)
				err := json.Unmarshal(responseData, &resp)
				if err != nil {
					errGlobal = err
					break
				}

				// Check for reserved but not published CVEs but continue the download
				if (resp.ResultsPerPage) == 0 {
					notFoundOnNVD = append(notFoundOnNVD, cveIDStr)
					log.Printf("%s: The CVE does not exist on NVD or is maybe a reserved CVE.", cveIDStr)
					break
				}

				// Check for rejected CVEs but continue the download
				if (resp.Vulnerabilities[0].Cve.VulnStatus) == "Rejected" {
					notFoundOnNVD = append(notFoundOnNVD, cveIDStr)
					log.Printf("%s: The CVE exists on NVD but is rejected.", cveIDStr)
					break
				}

				var cve model.CVE
				cve.ID = cveIDStr
				cve.Description = resp.Vulnerabilities[0].Cve.Descriptions[0].Value

				// Set the CVSS metric values based on the CVSS version
				if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31 != nil {
					cve.CVSSversion = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.Version
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AttackVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AttackComplexity
					cve.PrivilegesRequired = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.PrivilegesRequired
					cve.UserInteraction = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.UserInteraction
					cve.Scope = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.Scope
					cve.Authentication = "-"
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.ConfidentialityImpact
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.IntegrityImpact
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AvailabilityImpact
				} else if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30 != nil {
					cve.CVSSversion = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.Version
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AttackVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AttackComplexity
					cve.PrivilegesRequired = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.PrivilegesRequired
					cve.UserInteraction = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.UserInteraction
					cve.Scope = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.Scope
					cve.Authentication = "-"
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.ConfidentialityImpact
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.IntegrityImpact
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AvailabilityImpact
				} else if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2 != nil {
					cve.CVSSversion = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.Version
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AccessVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AccessComplexity
					cve.PrivilegesRequired = "-"
					cve.UserInteraction = "-"
					cve.Scope = "-"
					cve.Authentication = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.Authentication
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.ConfidentialityImpact[0:4]
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.IntegrityImpact[0:4]
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AvailabilityImpact[0:4]
				} else {
					return errors.New(cveIDStr + ": Something is wrong with the CVSS data."), listOfCVEs, notFoundOnNVD
				}

				listOfCVEs = append(listOfCVEs, cve)
				log.Printf("%s: The CVE was successfully added to the downloaded list.", cveIDStr)
			}
		}
	}
	return errGlobal, listOfCVEs, notFoundOnNVD
}

// Check if the CVE matches the different filter criteria
func FilterCVE(listOfCVE []model.CVE, cveFilter config.CVEFilter, conjunctionImpact string) []model.CVE {
	log.Println("Check if the CVE matches the different filter criteria.")
	logMsgFilterOut := "but the corresponding filter is not activated. CVE is filtered out."
	logMsgFilterOutCIA := "but does not match the corresponding filters and conjunction method \"" + conjunctionImpact + "\". CVE is filtered out."

	var listOfFilteredCVEs []model.CVE

	for _, cve := range listOfCVE {
		matchFilterConf := false
		matchFilterInt := false
		matchFilterAvail := false
		filterCatRelevant := true // mark if the cve should be filtered by range or category

		// Filter only by CVSS base score range when no base severity category is checked otherwise filter by base severity category
		filterValueCVSSv3SevLow, _ := cveFilter.BindingData.FilterCVSSv3BaseSeverityLow.Get()
		filterValueCVSSv3SevMed, _ := cveFilter.BindingData.FilterCVSSv3BaseSeverityMed.Get()
		filterValueCVSSv3SevHigh, _ := cveFilter.BindingData.FilterCVSSv3BaseSeverityHigh.Get()
		filterValueCVSSv3SevCrit, _ := cveFilter.BindingData.FilterCVSSv3BaseSeverityCrit.Get()
		filterValueCVSSv2SevLow, _ := cveFilter.BindingData.FilterCVSSv2BaseSeverityLow.Get()
		filterValueCVSSv2SevMed, _ := cveFilter.BindingData.FilterCVSSv2BaseSeverityMed.Get()
		filterValueCVSSv2SevHigh, _ := cveFilter.BindingData.FilterCVSSv2BaseSeverityHigh.Get()

		// Applies to CVSSvs3 and CVSSvs2
		if !filterValueCVSSv3SevLow && !filterValueCVSSv3SevMed && !filterValueCVSSv3SevHigh && !filterValueCVSSv3SevCrit &&
			!filterValueCVSSv2SevLow && !filterValueCVSSv2SevMed && !filterValueCVSSv2SevHigh {

			filterCatRelevant = false

			valueBaseScoreMin, _ := cveFilter.BindingData.FilterBaseScoreMin.Get()
			valueBaseScoreMax, _ := cveFilter.BindingData.FilterBaseScoreMax.Get()

			if (cve.BaseScore < valueBaseScoreMin) || (cve.BaseScore > valueBaseScoreMax) {
				log.Printf("%s: Base Score (%0.1f) is not in the filter range (%0.1f - %0.1f). CVE is filtered out.", cve.ID, cve.BaseScore, valueBaseScoreMin, valueBaseScoreMax)
				goto LOOPEND
			}
		}

		if (cve.CVSSversion == "3.1") || (cve.CVSSversion == "3.0") {
			//Filter by CVSS Base Severity
			if filterCatRelevant && cve.BaseSeverity == "LOW" && !filterValueCVSSv3SevLow {
				log.Printf("%s: Base Severity is \"LOW\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if filterCatRelevant && cve.BaseSeverity == "MEDIUM" && !filterValueCVSSv3SevMed {
				log.Printf("%s: Base Severity is \"MEDIUM\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if filterCatRelevant && cve.BaseSeverity == "HIGH" && !filterValueCVSSv3SevHigh {
				log.Printf("%s: Base Severity is \"HIGH\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if filterCatRelevant && cve.BaseSeverity == "CRITICAL" && !filterValueCVSSv3SevCrit {
				log.Printf("%s: Base Severity is \"CRITICAL\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}

			//Filter by CVSS metrics
			switch cve.AttackVector {
			case "NETWORK":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AVN.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			case "ADJACENT":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AVA.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			case "LOCAL":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AVL.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			case "PHYSICAL":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AVP.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.AttackComplexity {
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv3ACL.Get(); !value {
					log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
					goto LOOPEND
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv3ACH.Get(); !value {
					log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.PrivilegesRequired {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv3PRN.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv3PRL.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv3PRH.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.UserInteraction {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv3UIN.Get(); !value {
					log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
					goto LOOPEND
				}
			case "REQUIRED":
				if value, _ := cveFilter.BindingData.FilterCVSSv3UIR.Get(); !value {
					log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.Scope {
			case "UNCHANGED":
				if value, _ := cveFilter.BindingData.FilterCVSSv3SU.Get(); !value {
					log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
					goto LOOPEND
				}
			case "CHANGED":
				if value, _ := cveFilter.BindingData.FilterCVSSv3SC.Get(); !value {
					log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.Confidentiality {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv3CN.Get(); value {
					matchFilterConf = true
				}
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv3CL.Get(); value {
					matchFilterConf = true
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv3CH.Get(); value {
					matchFilterConf = true
				}
			}

			switch cve.Integrity {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv3IN.Get(); value {
					matchFilterInt = true
				}
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv3IL.Get(); value {
					matchFilterInt = true
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv3IH.Get(); value {
					matchFilterInt = true
				}
			}

			switch cve.Availability {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AN.Get(); value {
					matchFilterAvail = true
				}
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AL.Get(); value {
					matchFilterAvail = true
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv3AH.Get(); value {
					matchFilterAvail = true
				}
			}

			if conjunctionImpact == "OR" {
				if !(matchFilterConf || matchFilterInt || matchFilterAvail) {
					log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
					goto LOOPEND
				}
			} else {
				if !(matchFilterConf && matchFilterInt && matchFilterAvail) {
					log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
					goto LOOPEND
				}
			}
		} else {
			// Filter by CVSS Base Severity
			if filterCatRelevant && cve.BaseSeverity == "LOW" && !filterValueCVSSv2SevLow {
				log.Printf("%s: Base Severity is \"LOW\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if filterCatRelevant && cve.BaseSeverity == "MEDIUM" && !filterValueCVSSv2SevMed {
				log.Printf("%s: Base Severity is \"MEDIUM\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if filterCatRelevant && cve.BaseSeverity == "HIGH" && !filterValueCVSSv2SevHigh {
				log.Printf("%s: Base Severity is \"HIGH\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}

			//Filter by CVSS metrics
			switch cve.AttackVector {
			case "NETWORK":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AVN.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			case "ADJACENT":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AVA.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			case "LOCAL":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AVL.Get(); !value {
					log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.AttackComplexity {
			case "LOW":
				if value, _ := cveFilter.BindingData.FilterCVSSv2ACL.Get(); !value {
					log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
					goto LOOPEND
				}
			case "MEDIUM":
				if value, _ := cveFilter.BindingData.FilterCVSSv2ACM.Get(); !value {
					log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
					goto LOOPEND
				}
			case "HIGH":
				if value, _ := cveFilter.BindingData.FilterCVSSv2ACH.Get(); !value {
					log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.Authentication {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AUN.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			case "SINGLE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AUS.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			case "MULTIPLE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AUM.Get(); !value {
					log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
					goto LOOPEND
				}
			}

			switch cve.Confidentiality {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2CN.Get(); value {
					matchFilterConf = true
				}
			case "PART":
				if value, _ := cveFilter.BindingData.FilterCVSSv2CP.Get(); value {
					matchFilterConf = true
				}
			case "COMP":
				if value, _ := cveFilter.BindingData.FilterCVSSv2CC.Get(); value {
					matchFilterConf = true
				}
			}

			switch cve.Integrity {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2IN.Get(); value {
					matchFilterInt = true
				}
			case "PART":
				if value, _ := cveFilter.BindingData.FilterCVSSv2IP.Get(); value {
					matchFilterInt = true
				}
			case "COMP":
				if value, _ := cveFilter.BindingData.FilterCVSSv2IC.Get(); value {
					matchFilterInt = true
				}
			}

			switch cve.Availability {
			case "NONE":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AN.Get(); value {
					matchFilterAvail = true
				}
			case "PART":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AP.Get(); value {
					matchFilterAvail = true
				}
			case "COMP":
				if value, _ := cveFilter.BindingData.FilterCVSSv2AC.Get(); value {
					matchFilterAvail = true
				}
			}

			if conjunctionImpact == "OR" {
				if !(matchFilterConf || matchFilterInt || matchFilterAvail) {
					log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
					goto LOOPEND
				}
			} else {
				if !(matchFilterConf && matchFilterInt && matchFilterAvail) {
					log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
					goto LOOPEND
				}
			}
		}

		// 	Finally, add the CVE to the list as all filter criteria match
		listOfFilteredCVEs = append(listOfFilteredCVEs, cve)

	LOOPEND:
	}

	log.Println("The CVE filter process is finished.")
	return listOfFilteredCVEs
}

// Export as a csv file with semicolon as seperator
func ExportCVEListasCSV(fileURI string, tableHeadline []string, listOfCVE []model.CVE) error {
	var exportData = [][]string{tableHeadline}
	for _, cve := range listOfCVE {
		tmpArray := model.ConvCVEStruct(cve, len(tableHeadline), true)
		exportData = append(exportData, tmpArray)
	}

	if fileURI == "" {
		log.Println("File name for export is missing.")
		return nil
	}

	file, err := os.Create(fileURI)
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err
	}

	defer func() {
		err := file.Close()
		if err != nil {
			log.Println(err)
			return
		}
	}()

	csvwriter := csv.NewWriter(file)
	csvwriter.Comma = ';'
	defer csvwriter.Flush()

	err = csvwriter.WriteAll(exportData)
	if err != nil {
		log.Printf("Error when writing the CSV data to \"%s\": %s", fileURI, err)
		return err
	}

	log.Printf("Export saved to \"%s\"", file.Name())

	return nil
}

// Import a CSV file (with semicolon as seperator)
func ImportCVEListasCSV(fileURI string) (error, [][]string) {
	if fileURI == "" {
		log.Println("File name for import is missing.")
		return nil, nil
	}

	file, err := os.Open(fileURI)
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err, nil
	}

	defer func() {
		err := file.Close()
		if err != nil {
			log.Println(err)
			return
		}
	}()

	csvwriter := csv.NewReader(file)
	csvwriter.Comma = ';'

	importData, err := csvwriter.ReadAll()
	if err != nil {
		log.Printf("Error at reading the CSV data: %s", err)
		return err, nil
	}
	log.Printf("The raw import of the CSV data from \"%s\" (without content checking) was successful.", file.Name())

	return nil, importData
}
