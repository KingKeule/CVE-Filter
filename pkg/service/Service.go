package service

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"fyne.io/fyne/v2/widget"
	"github.com/KingKeule/CVE-Filter/pkg/config"
	"github.com/KingKeule/CVE-Filter/pkg/model"
)

var FastDL bool
var DownloadDelay = "6"

// API info: https://nvd.nist.gov/developers/vulnerabilities
const NVDApiURL = "http://services.nvd.nist.gov/rest/json/cves/2.0?cveId="

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^CVE-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// This function checks if the user input (string) contains only numbers.
func CheckUserDelayNum(delayString string) bool {
	s := strings.TrimSpace(delayString)
	r := regexp.MustCompile(`^\d+$`)
	return r.Match([]byte(s))
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(apiKeyWidget *widget.Entry, delayWidget *widget.Entry, progressInfo *widget.ProgressBar, stopDownload chan bool) (error, []model.CVE, []string) {

	var listOfCVEs []model.CVE
	var notFoundOnNVD []string
	var errGlobal error

	for i, cveIDStr := range model.ListOfCVEStrs {
		select {
		case <-stopDownload:
			log.Println("The user aborted the download process.")
			return errGlobal, listOfCVEs, notFoundOnNVD
		default:
			log.Printf("%s: Try to download the information from NVD", cveIDStr)

			httpClient := &http.Client{}
			req, _ := http.NewRequest("GET", NVDApiURL+cveIDStr, nil)
			//Set the user API key at fast download
			if (FastDL) && (len(model.ListOfCVEStrs) > 1) {
				req.Header.Set("apiKey", apiKeyWidget.Text)
			}
			response, err := httpClient.Do(req)
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}

			// Check for server message in the response header.
			// If a wrong API key is used, cancel the download.
			if FastDL {
				if response.Header.Get("message") == "Invalid apiKey." {
					log.Printf("The given API key is not valid. Please enter a valid API key.")
					return errors.New("Invalid API Key. Please enter a valid API key."), listOfCVEs, notFoundOnNVD
				} else {
					log.Printf("The given API key is valid and used.")
				}
			}

			responseData, err := ioutil.ReadAll(response.Body)
			if err != nil {
				return err, listOfCVEs, notFoundOnNVD
			}

			lenResp := len(responseData)
			log.Printf("%s: Recieved %d bytes from NVD.\n", cveIDStr, lenResp)
			if lenResp < 100 {
				// Check if the server is blocking the download in case of too many requests without key.
				// If so, cancel the download.
				nvdResp := string(responseData)
				if strings.Contains(nvdResp, "<html><body><h1>403 Forbidden</h1>") {
					log.Printf("%s: The request is blocked by the server.", cveIDStr)
					return errors.New(nvdResp), listOfCVEs, notFoundOnNVD
				}
			} else {
				var resp NVDResponse
				log.Printf("%s: The CVE was found at NVD and the JSON response is now trying to marshall.", cveIDStr)
				err := json.Unmarshal(responseData, &resp)
				if err != nil {
					errGlobal = err
					break
				}

				var cve model.CVE
				cve.ID = cveIDStr

				// Check for reserved but not published CVEs but continue the download
				if (resp.ResultsPerPage) == 0 {
					notFoundOnNVD = append(notFoundOnNVD, cveIDStr)
					log.Printf("%s: The CVE does not exist on NVD or is maybe a reserved CVE.", cveIDStr)
					progressInfo.SetValue(float64(i+1) / float64(len(model.ListOfCVEStrs)))
					break
				}

				// Set the CVSS metric values based on the CVSS version
				if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31 != nil {
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AttackVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AttackComplexity
					cve.PrivilegesRequired = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.PrivilegesRequired
					cve.UserInteraction = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.UserInteraction
					cve.Scope = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.Scope
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.ConfidentialityImpact
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.IntegrityImpact
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV31[0].CvssData.AvailabilityImpact
					cve.Description = resp.Vulnerabilities[0].Cve.Descriptions[0].Value
				} else if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30 != nil {
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AttackVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AttackComplexity
					cve.PrivilegesRequired = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.PrivilegesRequired
					cve.UserInteraction = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.UserInteraction
					cve.Scope = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.Scope
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.ConfidentialityImpact
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.IntegrityImpact
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV30[0].CvssData.AvailabilityImpact
					cve.Description = resp.Vulnerabilities[0].Cve.Descriptions[0].Value
				} else if resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2 != nil {
					cve.BaseScore = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.BaseScore
					cve.BaseSeverity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.BaseSeverity
					attackVector := resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AccessVector
					if attackVector == "ADJACENT_NETWORK" {
						attackVector = "ADJACENT"
					}
					cve.AttackVector = attackVector
					cve.AttackComplexity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AccessComplexity[0:3]
					cve.Confidentiality = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.ConfidentialityImpact[0:4]
					cve.Integrity = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.IntegrityImpact[0:4]
					cve.Availability = resp.Vulnerabilities[0].Cve.Metrics.CvssMetricV2[0].CvssData.AvailabilityImpact[0:4]
					cve.Description = resp.Vulnerabilities[0].Cve.Descriptions[0].Value
				} else {
					return errors.New(cveIDStr + ": Something is wrong with the CVSS data."), listOfCVEs, notFoundOnNVD
				}

				listOfCVEs = append(listOfCVEs, cve)
				log.Printf("%s: The CVE was successfully added to the downloaded list.", cveIDStr)
				progressInfo.SetValue(float64(i+1) / float64(len(model.ListOfCVEStrs)))
			}

			// Add the delay at download mode "slow" to prevent blocking from server
			if (!FastDL) && (len(model.ListOfCVEStrs) > 1) && !(i+1 == len(model.ListOfCVEStrs)) {
				delayValue, _ := strconv.Atoi(delayWidget.Text)
				log.Printf("Slow download delay. The next download will start in \"%d\" seconds.", delayValue)
				select {
				case <-stopDownload:
					break
				case <-time.After(time.Duration(delayValue) * time.Second):
					break
				}
			}
		}
	}
	return errGlobal, listOfCVEs, notFoundOnNVD
}

// Check if the CVE matches the different filter criteria
func FilterCVE(listOfCVE []model.CVE, cveFilter config.CVEFilter, conjunctionImpact string) []model.CVE {
	log.Println("Check if the CVE matches the different filter criteria.")
	logMsgFilterOut := "but the corresponding filter is not activated. CVE is filtered out."
	logMsgFilterOutCIA := "but does not match the corresponding filters and conjunction method \"" + conjunctionImpact + "\". CVE is filtered out."

	var listOfFilteredCVEs []model.CVE

	for _, cve := range listOfCVE {

		matchFilterConf := false
		matchFilterInt := false
		matchFilterAvail := false

		//Filter only by CVSS base score range when no base severity category is checked otherwise filter by base severity category
		filterValueSevLow, _ := cveFilter.BindingData.FilterBaseSeverityLow.Get()
		filterValueSevMed, _ := cveFilter.BindingData.FilterBaseSeverityMed.Get()
		filterValueSevHigh, _ := cveFilter.BindingData.FilterBaseSeverityHigh.Get()
		filterValueSevCrit, _ := cveFilter.BindingData.FilterBaseSeverityCrit.Get()

		if !filterValueSevLow && !filterValueSevMed && !filterValueSevHigh && !filterValueSevCrit {
			valueBaseScoreMin, _ := cveFilter.BindingData.FilterBaseScoreMin.Get()
			valueBaseScoreMax, _ := cveFilter.BindingData.FilterBaseScoreMax.Get()
			if (cve.BaseScore < valueBaseScoreMin) || (cve.BaseScore > valueBaseScoreMax) {
				log.Printf("%s: Base Score (%0.1f) is not in the filter range (%0.1f - %0.1f). CVE is filtered out.", cve.ID, cve.BaseScore, valueBaseScoreMin, valueBaseScoreMax)
				goto LOOPEND
			}
		} else {
			if cve.BaseSeverity == "LOW" && !filterValueSevLow {
				log.Printf("%s: Base Severity is \"LOW\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "MEDIUM" && !filterValueSevMed {
				log.Printf("%s: Base Severity is \"MEDIUM\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "HIGH" && !filterValueSevHigh {
				log.Printf("%s: Base Severity is \"HIGH\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
			if cve.BaseSeverity == "CRITICAL" && !filterValueSevCrit {
				log.Printf("%s: Base Severity is \"CRITICAL\" %s", cve.ID, logMsgFilterOut)
				goto LOOPEND
			}
		}

		//Filter by CVSS metrics
		switch cve.AttackVector {
		case "NETWORK":
			if value, _ := cveFilter.BindingData.FilterAVN.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "ADJACENT":
			if value, _ := cveFilter.BindingData.FilterAVA.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOCAL":
			if value, _ := cveFilter.BindingData.FilterAVL.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		case "PHYSICAL":
			if value, _ := cveFilter.BindingData.FilterAVP.Get(); !value {
				log.Printf("%s: Attack vector is \"%s\" %s", cve.ID, cve.AttackVector, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.AttackComplexity {
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterACL.Get(); !value {
				log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterACH.Get(); !value {
				log.Printf("%s: Attack complexity is \"%s\" %s", cve.ID, cve.AttackComplexity, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.PrivilegesRequired {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterPRN.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterPRL.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterPRH.Get(); !value {
				log.Printf("%s: Privileges required is \"%s\" %s", cve.ID, cve.PrivilegesRequired, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.UserInteraction {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterUIN.Get(); !value {
				log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
				goto LOOPEND
			}
		case "REQUIRED":
			if value, _ := cveFilter.BindingData.FilterUIR.Get(); !value {
				log.Printf("%s: User interaction is \"%s\" %s", cve.ID, cve.UserInteraction, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Scope {
		case "UNCHANGED":
			if value, _ := cveFilter.BindingData.FilterSU.Get(); !value {
				log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
				goto LOOPEND
			}
		case "CHANGED":
			if value, _ := cveFilter.BindingData.FilterSC.Get(); !value {
				log.Printf("%s: Scope is \"%s\" %s", cve.ID, cve.Scope, logMsgFilterOut)
				goto LOOPEND
			}
		}

		switch cve.Confidentiality {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterCN.Get(); value {
				matchFilterConf = true
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterCL.Get(); value {
				matchFilterConf = true
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterCH.Get(); value {
				matchFilterConf = true
			}
		}

		switch cve.Integrity {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterIN.Get(); value {
				matchFilterInt = true
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterIL.Get(); value {
				matchFilterInt = true
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterIH.Get(); value {
				matchFilterInt = true
			}
		}

		switch cve.Availability {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterAN.Get(); value {
				matchFilterAvail = true
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterAL.Get(); value {
				matchFilterAvail = true
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterAH.Get(); value {
				matchFilterAvail = true
			}
		}

		if conjunctionImpact == "OR" {
			if !(matchFilterConf || matchFilterInt || matchFilterAvail) {
				log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
				goto LOOPEND
			}
		} else {
			if !(matchFilterConf && matchFilterInt && matchFilterAvail) {
				log.Printf("%s: CIA values are \"%s\", \"%s\", \"%s\" %s", cve.ID, cve.Confidentiality, cve.Integrity, cve.Availability, logMsgFilterOutCIA)
				goto LOOPEND
			}
		}

		// 	Finally, add the CVE to the list as all filter criteria match
		listOfFilteredCVEs = append(listOfFilteredCVEs, cve)

	LOOPEND:
	}

	log.Println("The CVE filter process is finished.")
	return listOfFilteredCVEs
}

// Export as a csv file with semicolon as seperator
func ExportCVEListasCSV(fileURI string, tableHeadline []string, listOfCVE []model.CVE) error {
	var exportData = [][]string{tableHeadline}
	for _, cve := range listOfCVE {
		tmpArray := model.ConvCVEStruct(cve, len(tableHeadline))
		exportData = append(exportData, tmpArray)
	}

	if fileURI == "" {
		log.Println("File name for export is missing.")
		return nil
	}

	file, err := os.Create(fileURI)
	defer file.Close()
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err
	}

	csvwriter := csv.NewWriter(file)
	csvwriter.Comma = ';'
	defer csvwriter.Flush()

	err = csvwriter.WriteAll(exportData)
	if err != nil {
		log.Println(err)
		return err
	}

	log.Printf("Export saved to \"%s\"", file.Name())

	return nil
}
