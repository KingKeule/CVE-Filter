package service

import (
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"strings"
)

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^CVE-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(listOfCVEStr []string) (bool, []CVE) {

	var listOfCVEs []CVE
	result := true
	searchStrVector1 := `attackVector`
	searchStrVector2 := `,"baseScore`
	searchStrScore1 := `baseScore":`
	searchStrScore2 := `,"baseSeverity`

	for _, cveIDStr := range listOfCVEStr {
		log.Printf("Try to download the information for \"%s\" from NVD", cveIDStr)

		// API info: https://nvd.nist.gov/developers/vulnerabilities
		response, err := http.Get("https://services.nvd.nist.gov/rest/json/cve/1.0/" + cveIDStr)
		if err != nil {
			log.Println(err.Error())
			result = false
			break
		}

		responseData, err := ioutil.ReadAll(response.Body)
		if err != nil {
			log.Println(err.Error())
			result = false
			break
		}

		lenResp := len(responseData)
		log.Printf("Recieved %d bytes from NVD.\n", lenResp)
		nvdResp := string(responseData)
		//log.Println(nvdResp)

		if lenResp < 100 { // check for bad response: {"message":"Unable to find vuln CVE-XXXX-XXXXX"}
			log.Printf("Problem: %s", nvdResp)
			result = false
			break
		} else {
			// Extract the substring with the CVSS vector information
			posFirst := strings.Index(nvdResp, searchStrVector1)
			posLast := strings.Index(nvdResp, searchStrVector2)
			cvss31MetricSlice := nvdResp[posFirst:posLast]
			cvss31Metrics := strings.Split(cvss31MetricSlice, ",")

			// Extract the substring with the CVSS score information
			scorePosFirst := strings.Index(nvdResp, searchStrScore1)
			scorePosLast := strings.Index(nvdResp, searchStrScore2)
			cvss31Score := nvdResp[(scorePosFirst + len(searchStrScore1)):scorePosLast]

			var cve CVE
			cve.ID = cveIDStr
			cve.Score = cvss31Score
			cve.AttackVector = cvss31Metrics[0][15 : len(cvss31Metrics[0])-1]
			cve.AttackComplexity = cvss31Metrics[1][20 : len(cvss31Metrics[1])-1]
			cve.PrivilegesRequired = cvss31Metrics[2][22 : len(cvss31Metrics[2])-1]
			cve.UserInteraction = cvss31Metrics[3][19 : len(cvss31Metrics[3])-1]
			cve.Scope = cvss31Metrics[4][9 : len(cvss31Metrics[4])-1]
			cve.Confidentiality = cvss31Metrics[5][25 : len(cvss31Metrics[5])-1]
			cve.Integrity = cvss31Metrics[6][19 : len(cvss31Metrics[6])-1]
			cve.Availability = cvss31Metrics[7][22 : len(cvss31Metrics[7])-1]

			listOfCVEs = append(listOfCVEs, cve)
		}
	}
	return result, listOfCVEs
}
