package service

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"

	"github.com/KingKeule/CVE-Filter/pkg/config"
	"github.com/KingKeule/CVE-Filter/pkg/model"
)

// Try to parse the GUI input into individual CVEs strings and check if they match the CVE syntax
func ParseGuiInput(input string) (bool, []string) {

	log.Printf("Try to split the GUI input \"%s\" into a list of possible CVEs strings.", input)
	CVEStrArray := strings.Split(input, ",")

	// check if the cve has the correct syntax/pattern
	var CVEStrArrayChecked []string
	result := true
	log.Println("Check each CVEs strings if the string has the correct CVE syntax/pattern.")
	CVEpattern := regexp.MustCompile(`^CVE-20\d{2}-\d{4,7}$`) //maybe add year 1999

	for _, cveString := range CVEStrArray {
		result = CVEpattern.MatchString(cveString)
		if result {
			CVEStrArrayChecked = append(CVEStrArrayChecked, cveString)
			log.Printf("The input \"%s\" match the CVE pattern.", cveString)
		} else {
			log.Printf("The input \"%s\" does not match the CVE pattern \"%s\".", cveString, CVEpattern)
			break
		}
	}

	return result, CVEStrArrayChecked
}

// Try to download the information for each CVE from NVD and get the CVSS metrics
func DlCVEDetails(listOfCVEStr []string) (error, []model.CVE, []string) {

	var listOfCVEs []model.CVE
	var notFoundOnNVD []string
	var errGlobal error

	for _, cveIDStr := range listOfCVEStr {
		log.Printf("Try to download the information for \"%s\" from NVD", cveIDStr)

		// API info: https://nvd.nist.gov/developers/vulnerabilities
		response, err := http.Get("https://services.nvd.nist.gov/rest/json/cve/1.0/" + cveIDStr)
		if err != nil {
			errGlobal = err
			break
		}

		responseData, err := ioutil.ReadAll(response.Body)
		if err != nil {
			errGlobal = err
			break
		}

		lenResp := len(responseData)
		log.Printf("Recieved %d bytes from NVD.\n", lenResp)
		if lenResp < 100 {
			nvdResp := string(responseData)
			if strings.Contains(nvdResp, "Unable to find vuln") {
				notFoundOnNVD = append(notFoundOnNVD, cveIDStr)
			} else {
				errGlobal = errors.New(nvdResp)
			}

		} else {
			var resp NVDResponse
			log.Printf("Try to marshall the JSON response from NVD")
			json.Unmarshal(responseData, &resp)

			var cve model.CVE
			cve.ID = cveIDStr
			cve.BaseScore = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.BaseScore
			cve.BaseSeverity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.BaseSeverity
			cve.AttackVector = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AttackVector
			cve.AttackComplexity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AttackComplexity
			cve.PrivilegesRequired = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.PrivilegesRequired
			cve.UserInteraction = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.UserInteraction
			cve.Scope = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.Scope
			cve.Confidentiality = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.ConfidentialityImpact
			cve.Integrity = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.IntegrityImpact
			cve.Availability = resp.Result.CVEItems[0].Impact.BaseMetricV3.CvssV3.AvailabilityImpact

			listOfCVEs = append(listOfCVEs, cve)
		}
	}
	return errGlobal, listOfCVEs, notFoundOnNVD
}

// Check if the CVE matches the different filter criteria
func FilterCVE(listOfCVE []model.CVE, cveFilter config.CVEFilter) []model.CVE {
	log.Println("Check if the CVE matches the different filter criteria.")

	var listOfFilteredCVEs []model.CVE

	for _, cve := range listOfCVE {

		//Filter only by CVSS base score range when no base severity category is checked otherwise filter by base severity category
		filterValueSevLow, _ := cveFilter.BindingData.FilterBaseSeverityLow.Get()
		filterValueSevMed, _ := cveFilter.BindingData.FilterBaseSeverityMed.Get()
		filterValueSevHigh, _ := cveFilter.BindingData.FilterBaseSeverityHigh.Get()
		filterValueSevCrit, _ := cveFilter.BindingData.FilterBaseSeverityCrit.Get()

		if !filterValueSevLow && !filterValueSevMed && !filterValueSevHigh && !filterValueSevCrit {
			valueBaseScoreMin, _ := cveFilter.BindingData.FilterBaseScoreMin.Get()
			valueBaseScoreMax, _ := cveFilter.BindingData.FilterBaseScoreMax.Get()
			if (cve.BaseScore < valueBaseScoreMin) || (cve.BaseScore > valueBaseScoreMax) {
				log.Printf("%s: Base Score (%0.1f) is not in the filter range (%0.1f - %0.1f). CVE is filtered out.", cve.ID, cve.BaseScore, valueBaseScoreMin, valueBaseScoreMax)
				goto LOOPEND
			}
		} else {
			if cve.BaseSeverity == "LOW" && !filterValueSevLow {
				log.Printf("%s: Base Severity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverity == "MEDIUM" && !filterValueSevMed {
				log.Printf("%s: Base Severity is not \"MEDIUM\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverity == "HIGH" && !filterValueSevHigh {
				log.Printf("%s: Base Severity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
			if cve.BaseSeverity == "CRITICAL" && !filterValueSevCrit {
				log.Printf("%s: Base Severity is not \"CRITICAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		//Filter by CVSS metrics
		switch cve.AttackVector {
		case "NETWORK":
			if value, _ := cveFilter.BindingData.FilterAVN.Get(); !value {
				log.Printf("%s: Attack vector is not \"NETWORK\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "ADJACENT":
			if value, _ := cveFilter.BindingData.FilterAVA.Get(); !value {
				log.Printf("%s: Attack vector is not \"ADJACENT\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOCAL":
			if value, _ := cveFilter.BindingData.FilterAVL.Get(); !value {
				log.Printf("%s: Attack vector is not \"LOCAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "PHYSICAL":
			if value, _ := cveFilter.BindingData.FilterAVP.Get(); !value {
				log.Printf("%s: Attack vector is not \"PHYSICAL\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.AttackComplexity {
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterACL.Get(); !value {
				log.Printf("%s: Attack complexity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterACH.Get(); !value {
				log.Printf("%s: Attack complexity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.PrivilegesRequired {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterPRN.Get(); !value {
				log.Printf("%s: Privileges required is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterPRL.Get(); !value {
				log.Printf("%s: Privileges required is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterPRH.Get(); !value {
				log.Printf("%s: Privileges required is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.UserInteraction {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterUIN.Get(); !value {
				log.Printf("%s: User interaction is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "REQUIRED":
			if value, _ := cveFilter.BindingData.FilterUIR.Get(); !value {
				log.Printf("%s: User interaction is not \"REQUIRED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Scope {
		case "UNCHANGED":
			if value, _ := cveFilter.BindingData.FilterSU.Get(); !value {
				log.Printf("%s: Scope is not \"UNCHANGED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "CHANGED":
			if value, _ := cveFilter.BindingData.FilterSC.Get(); !value {
				log.Printf("%s: Scope is not \"CHANGED\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Confidentiality {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterCN.Get(); !value {
				log.Printf("%s: Confidentiality is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterCL.Get(); !value {
				log.Printf("%s: Confidentiality is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterCH.Get(); !value {
				log.Printf("%s: Confidentiality is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Integrity {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterIN.Get(); !value {
				log.Printf("%s: Integrity is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterIL.Get(); !value {
				log.Printf("%s: Integrity is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterIH.Get(); !value {
				log.Printf("%s: Integrity is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		switch cve.Availability {
		case "NONE":
			if value, _ := cveFilter.BindingData.FilterAN.Get(); !value {
				log.Printf("%s: Availability is not \"NONE\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "LOW":
			if value, _ := cveFilter.BindingData.FilterAL.Get(); !value {
				log.Printf("%s: Availability is not \"LOW\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		case "HIGH":
			if value, _ := cveFilter.BindingData.FilterAH.Get(); !value {
				log.Printf("%s: Availability required is not \"HIGH\". CVE is filtered out.", cve.ID)
				goto LOOPEND
			}
		}

		// 	Finally, add the CVE to the list as all filter criteria match
		listOfFilteredCVEs = append(listOfFilteredCVEs, cve)

	LOOPEND:
	}

	return listOfFilteredCVEs
}

// Export as a csv file with semicolon as seperator
func ExportCVEListasCSV(fileURI string, tableHeadline []string, listOfCVE []model.CVE) error {
	var exportData = [][]string{tableHeadline}
	for _, cve := range listOfCVE {
		tmpArray := model.ConvCVEStruct(cve, len(tableHeadline))
		exportData = append(exportData, tmpArray)
	}

	if fileURI == "" {
		log.Println("File name for export is missing.")
		return errors.New("")
	}

	file, err := os.Create(fileURI)
	defer file.Close()
	if err != nil {
		log.Printf("Failed to open file \"%s\". Error: %s", fileURI, err)
		return err
	}

	csvwriter := csv.NewWriter(file)
	csvwriter.Comma = ';'
	defer csvwriter.Flush()

	err = csvwriter.WriteAll(exportData)
	if err != nil {
		log.Println(err)
		return err
	}

	log.Printf("Export saved to \"%s\"", file.Name())

	return nil
}
